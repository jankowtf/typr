% Generated by roxygen2 (4.0.2): do not edit by hand
\name{setTyped}
\alias{setTyped}
\title{Set Typed Object Value (S3)}
\usage{
setTyped(id, value = NULL, where = parent.frame(), numint = TRUE,
  from_null = TRUE, to_null = TRUE, inherit = FALSE, strict = c(2, 1,
  0), ...)
}
\arguments{
\item{id}{\code{\link{character}}.
Name/ID of the typed object to create.}

\item{value}{\code{\link{ANY}}.
Object value.}

\item{where}{\code{\link{environment}}.
Environment in which to create the object.}

\item{numint}{\code{\link{logical}}.
\code{TRUE}: do not distinguish between types (classes) \code{numeric}
and \code{integer};
\code{FALSE}: threat them as two different types (classes).
Default: \code{TRUE} as this seems to make most sense in practical
applications.}

\item{from_null}{\code{\link{logical}}.
\code{TRUE}: any type (class) is valid to overwrite an initial \code{NULL}
value.
\code{FALSE}: this would be regarded as a type (class) mismatch.
Default: \code{TRUE} as this seems to make most sense in practical
applications.}

\item{to_null}{\code{\link{logical}}.
\code{TRUE}: value of \code{NULL} is always valid type (class) regardless
of the type (class) that was stored at the initial assignment operation.
\code{FALSE}: this would be regarded as a type (class) mismatch.
Default: \code{TRUE} as this seems to make most sense in practical
applications.}

\item{inherit}{\code{\link{logical}}.
\code{TRUE}: visible typed value inherits from informal S3
class \code{TypedObject};
\code{FALSE}: class table not altered.
Default: \code{FALSE} to provide maximum amount of compatibality with
S3 method dispatch.}

\item{strict}{\code{\link{numeric}}.
Relevant if assigning an explicit value to an object with reactive
dependency on other objects.
reactive relationship.
\itemize{
  \item{\code{0}: } {ignore without warning}
  \item{\code{1}: } {ignore with Warning}
  \item{\code{2}: } {stop with error}
}}

\item{...}{Further arguments to be passed to subsequent functions/methods.
In particular, all environments of references that you are referring to
in the body of the binding function.
See section \emph{Referenced environments}.}
}
\description{
Creates an implicitly typed object.
}
\details{
The type (class) of \code{value} is remembered and stored in an invisible
object part curtesy of \code{\link[base]{makeActiveBinding}}. For any
subsequent assignment operations on the object, the type (class) of
\code{value} is checked against the originally stored type (class).
Type (class) mismatches trigger an error, a warning or are silently
ignored depending on the value of \code{strict}.
}
\examples{
\dontrun{

##------------------------------------------------------------------------------
## Levels of strictness //
##------------------------------------------------------------------------------

## Strict = 2 //
(setTyped(id = "x_1", value = 10))
x_1
try(x_1 <- "hello world!")
## --> ignored with error
x_1

## Strict = 1 //
setTyped(id = "x_1", value = 10, strict = 1)
try(x_1 <- "hello world!")
## --> ignored with warning
x_1

## Strict = 0 //
setTyped(id = "x_1", value = 10, strict = 0)
x_1 <- "hello world!"
x_1
## --> simply ignored

##------------------------------------------------------------------------------
## NULL //
##------------------------------------------------------------------------------

## Change from NULL //
(setTyped(id = "x_1"))
x_1
x_1 <- "hello world!"
x_1
## --> overwritten

setTyped(id = "x_1", from_null = FALSE)
try(x_1 <- "hello world!")
## --> ignored with error

setTyped(id = "x_1", from_null = FALSE, strict = 1)
try(x_1 <- "hello world!")
## --> ignored with warning

setTyped(id = "x_1", from_null = FALSE, strict = 0)
x_1 <- "hello world!"
x_1
## --> simply ignored

## Change to NULL //
setTyped(id = "x_1", value = 10)
x_1 <- NULL
x_1
## --> overwritten

setTyped(id = "x_1", value = 10, to_null = FALSE)
try(x_1 <- NULL)
## --> ignored with error

setTyped(id = "x_1", value = 10, to_null = FALSE, strict = 1)
try(x_1 <- NULL)
## --> ignored with warning

setTyped(id = "x_1", value = 10, to_null = FALSE, strict = 0)
x_1 <- NULL
x_1
## --> simply ignored

##------------------------------------------------------------------------------
## Numerical values //
##------------------------------------------------------------------------------

## Change from `numeric` to `integer` //
setTyped(id = "x_1", 10)
class(x_1)
## --> numeric

(x_1 <- as.integer(20))
class(x_1)
## --> overwritten

setTyped(id = "x_1", 10, numint = FALSE)
try(x_1 <- as.integer(20))
## --> ignored with error

setTyped(id = "x_1", 10, numint = FALSE, strict = 1)
try(x_1 <- as.integer(20))
## --> ignored with warning

setTyped(id = "x_1", 10, numint = FALSE, strict = 0)
x_1 <- as.integer(20)
x_1
class(x_1)
## --> simply ignored

## Change from `integer` to `numeric` //
(setTyped(id = "x_1", as.integer(10)))
class(x_1)
## --> integer

x_1 <- 20
x_1
class(x_1)
## --> overwritten

setTyped("x_1", as.integer(10), numint = FALSE)
try(x_1 <- 20)
## --> ignored with error

setTyped("x_1", as.integer(10), numint = FALSE)
try(x_1 <- 20)
## --> ignored with warning

setTyped("x_1", as.integer(10), numint = FALSE, strict = 0)
x_1 <- 20
x_1
class(x_1)
## --> simply ignored

##------------------------------------------------------------------------------
## Inheritance //
##------------------------------------------------------------------------------

value <- structure(10, class = c("MyNumeric", "numeric"))

setTyped(id = "x_1", value)
x_1
inherits(x_1, "MyNumeric")
inherits(x_1, "numeric")

x_1 <- as.integer(20)
x_1
## --> overwritten

setTyped(id = "x_1", value, numint = FALSE)
try(x_1 <- as.integer(10))
## --> ignored with error
## --> note the information that any of {`MyNumeric`, `numeric`} would be 
## a valid type (class)
x_1

}
}
\author{
Janko Thyson \email{janko.thyson@rappster.de}
}
\references{
\url{http://github.com/Rappster/typr}
}
\seealso{
\code{
    \link[base]{makeActiveBinding}
}
}

